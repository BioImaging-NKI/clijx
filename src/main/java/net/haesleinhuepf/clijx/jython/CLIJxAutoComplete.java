package net.haesleinhuepf.clijx.jython;
import org.fife.ui.autocomplete.BasicCompletion;
import net.haesleinhuepf.clijx.jython.ScriptingAutoCompleteProvider;
import java.util.ArrayList;// this is generated code. See src/test/java/net/haesleinhuepf/clijx/codegenerator for details
class CLIJxAutoComplete {
   
   public static ArrayList<BasicCompletion> getCompletions(final ScriptingAutoCompleteProvider provider) {
       ArrayList<BasicCompletion> list = new ArrayList<BasicCompletion>();
       String headline;
       String description;
       headline = "clijx.absoluteInplace(ClearCLBuffer source_destination)";
       description = "<b>absoluteInplace</b><br><br>Computes the absolute value of every individual pixel x in a given image.<br><br><pre>f(x) = |x| </pre><br><br>Parameters:<br>ClearCLBuffer source_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.absolute(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>absolute</b><br><br>Computes the absolute value of every individual pixel x in a given image.<br><br><pre>f(x) = |x| </pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>addImageAndScalar</b><br><br>Adds a scalar value s to all pixels x of a given image X.<br><br><pre>f(x, s) = x + s</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImagesWeighted(ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination, Float factor1, Float factor2)";
       description = "<b>addImagesWeighted</b><br><br>Calculates the sum of pairs of pixels x and y from images X and Y weighted with factors a and b.<br><br><pre>f(x, y, a, b) = x * a + y * b</pre><br><br>Parameters:<br>ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination, Float factor1, Float factor2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImages(ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination)";
       description = "<b>addImages</b><br><br>Calculates the sum of pairs of pixels x and y of two images X and Y.<br><br><pre>f(x, y) = x + y</pre><br><br>Parameters:<br>ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.affineTransform2D(ClearCLBuffer source, ClearCLImageInterface destination, String transform)";
       description = "<b>affineTransform2D</b><br><br>Applies an affine transform to a 2D image. Individual transforms must be separated by spaces.<br><br>Supported transforms:<br>* center: translate the coordinate origin to the center of the image<br>* -center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;center scale=2 rotate=45 -center&quot;;<br><br>Parameters:<br>ClearCLBuffer source, ClearCLImageInterface destination, String transform";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.affineTransform3D(ClearCLBuffer source, ClearCLImageInterface destination, String transform)";
       description = "<b>affineTransform3D</b><br><br>Applies an affine transform to a 3D image. Individual transforms must be separated by spaces.<br><br>Supported transforms:<br>* center: translate the coordinate origin to the center of the image<br>* -center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* rotateX=[angle]: rotate in Y/Z plane (around X-axis) by the given angle in degrees<br>* rotateY=[angle]: rotate in X/Z plane (around Y-axis) by the given angle in degrees<br>* rotateZ=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* scaleZ=[factor]: scaling along Z-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* shearXZ=[factor]: shearing along X-axis in XZ plane according to given factor<br>* shearYX=[factor]: shearing along Y-axis in XY plane according to given factor<br>* shearYZ=[factor]: shearing along Y-axis in YZ plane according to given factor<br>* shearZX=[factor]: shearing along Z-axis in XZ plane according to given factor<br>* shearZY=[factor]: shearing along Z-axis in YZ plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br>* translateZ=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;center scale=2 rotate=45 -center&quot;;<br><br>Parameters:<br>ClearCLBuffer source, ClearCLImageInterface destination, String transform";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorField2D(ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination)";
       description = "<b>applyVectorField2D</b><br><br>Deforms an image according to distances provided in the given vector images. It is recommended to use 32-bit images for input, output and vector images. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorField3D(ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface vectorZ, ClearCLImageInterface destination)";
       description = "<b>applyVectorField3D</b><br><br>Deforms an image stack according to distances provided in the given vector image stacks. It is recommended to use 32-bit image stacks for input, output and vector image stacks. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface vectorZ, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorField(ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination)";
       description = "<b>applyVectorField</b><br><br>Deforms an image according to distances provided in the given vector images. It is recommended to use 32-bit images for input, output and vector images. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyWekaModel(ClearCLBuffer featureStack3D, ClearCLBuffer prediction2D_destination, String loadModelFilename)";
       description = "<b>applyWekaModel</b><br><br>Applies a Weka model using functionality of Fijis Trainable Weka Segmentation plugin.<br>It takes a 3D feature stack (e.g. first plane original image, second plane blurred, third plane edge image)and applies a pre-trained a Weka model. Take care that the feature stack has been generated in the sameway as for training the model!<br><br>Parameters:<br>ClearCLBuffer featureStack3D, ClearCLBuffer prediction2D_destination, String loadModelFilename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.argMaximumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max, ClearCLImageInterface destination_arg_max)";
       description = "<b>argMaximumZProjection</b><br><br>Determines the maximum projection of an image stack along Z.<br>Furthermore, another 2D image is generated with pixels containing the z-index where the maximum was found (zero based).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max, ClearCLImageInterface destination_arg_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.automaticThresholdInplace(ClearCLBuffer input_and_destination, String method)";
       description = "<b>automaticThresholdInplace</b><br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method. Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Parameters:<br>ClearCLBuffer input_and_destination, String method";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.automaticThreshold(ClearCLBuffer input, ClearCLBuffer destination, String method)";
       description = "<b>automaticThreshold</b><br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method. Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, String method";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryAnd(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryAnd</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary AND operator &.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = x & y</pre><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryNot(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>binaryNot</b><br><br>Computes a binary image (containing pixel values 0 and 1) from an image X by negating its pixel values<br>x using the binary NOT operator !<br>All pixel values except 0 in the input image are interpreted as 1.<br><br><pre>f(x) = !x</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryOr(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryOr</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary OR operator |.<br>All pixel values except 0 in the input images are interpreted as 1.<pre>f(x, y) = x | y</pre><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryXOr(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryXOr</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary operators AND &, OR | and NOT ! implementing the XOR operator.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = (x & !y) | (!x & y)</pre><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur2D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>blur2D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur3D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ)";
       description = "<b>blur3D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X, Y and Z. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blurSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>blurSliceBySlice</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The Gaussian blur is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>blur</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.boundingBox(ClearCLBuffer source)";
       description = "<b>boundingBox</b><br><br>Determines the bounding box of all non-zero pixels in a binary image. The positions will be stored in a new row of ImageJs<br>Results table in the column 'BoundingBoxX', 'BoundingBoxY', 'BoundingBoxZ', 'BoundingBoxWidth', 'BoundingBoxHeight' 'BoundingBoxDepth'.In case of 2D images Z and depth will be zero.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.centerOfMass(ClearCLBuffer source)";
       description = "<b>centerOfMass</b><br><br>Determines the center of mass of an image or image stack and writes the result in the results table<br>in the columns MassX, MassY and MassZ.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.connectedComponentsLabelingInplace(ClearCLBuffer binary_source_labeling_destination)";
       description = "<b>connectedComponentsLabelingInplace</b><br><br>Performs connected components analysis to a binary image and generates a label map.<br><br>Parameters:<br>ClearCLBuffer binary_source_labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.copySlice(ClearCLImageInterface source, ClearCLImageInterface destination, Integer sliceIndex)";
       description = "<b>copySlice</b><br><br>This method has two purposes: <br>It copies a 2D image to a given slice z position in a 3D image stack or <br>It copies a given slice at position z in an image stack to a 2D image.<br><br>The first case is only available via ImageJ macro. If you are using it, it is recommended that the <br>target 3D image already pre-exists in GPU memory before calling this method. Otherwise, CLIJ create <br>the image stack with z planes.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer sliceIndex";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.copy(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>copy</b><br><br>Copies an image.<br><br><pre>f(x) = x</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixels2DSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>countNonZeroPixels2DSphere</b><br><br>Counts non-zero pixels in a sphere around every pixel.Put the number in the result image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixelsSliceBySliceSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>countNonZeroPixelsSliceBySliceSphere</b><br><br>Counts non-zero pixels in a sphere around every pixel slice by slice in a stack and puts the resulting number in the destination image stack.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixels(ClearCLBuffer source)";
       description = "<b>countNonZeroPixels</b><br><br>Determines the number of all pixels in a given image which are not equal to 0. It will be stored in a new row of ImageJs<br>Results table in the column 'CountNonZero'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroVoxels3DSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>countNonZeroVoxels3DSphere</b><br><br>Counts non-zero voxels in a sphere around every voxel.Put the number in the result image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMaximaBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius)";
       description = "<b>detectMaximaBox</b><br><br>Detects local maxima in a given square/cubic neighborhood. Pixels in the resulting image are set to 1 if<br>there is no other pixel in a given radius which has a higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMaximaSliceBySliceBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radius)";
       description = "<b>detectMaximaSliceBySliceBox</b><br><br>Detects local maxima in a given square neighborhood of an input image stack. The input image stack is <br>processed slice by slice. Pixels in the resulting image are set to 1 if there is no other pixel in a <br>given radius which has a higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMinimaBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius)";
       description = "<b>detectMinimaBox</b><br><br>Detects local minima in a given square/cubic neighborhood. Pixels in the resulting image are set to 1 if<br>there is no other pixel in a given radius which has a lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMinimaSliceBySliceBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radius)";
       description = "<b>detectMinimaSliceBySliceBox</b><br><br>Detects local minima in a given square neighborhood of an input image stack. The input image stack is <br>processed slice by slice. Pixels in the resulting image are set to 1 if there is no other pixel in a <br>given radius which has a lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussianInplace3D(ClearCLBuffer input_and_destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z)";
       description = "<b>differenceOfGaussianInplace3D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer input_and_destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateBoxSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateBoxSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateBox(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateBox</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateSphereSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateSphereSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateSphere(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateSphere</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.divideImages(ClearCLImageInterface divident, ClearCLImageInterface divisor, ClearCLImageInterface destination)";
       description = "<b>divideImages</b><br><br>Divides two images X and Y by each other pixel wise.<br><br><pre>f(x, y) = x / y</pre><br><br>Parameters:<br>ClearCLImageInterface divident, ClearCLImageInterface divisor, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample2D(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY)";
       description = "<b>downsample2D</b><br><br>Scales an image using given scaling factors for X and Y dimensions. The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample3D(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ)";
       description = "<b>downsample3D</b><br><br>Scales an image using given scaling factors for X and Y dimensions. The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsampleSliceBySliceHalfMedian(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>downsampleSliceBySliceHalfMedian</b><br><br>Scales an image using scaling factors 0.5 for X and Y dimensions. The Z dimension stays untouched. Thus, each slice is processed separately.<br>The median method is applied. Thus, each pixel value in the destination image equals to the median of<br>four corresponding pixels in the source image.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY)";
       description = "<b>downsample</b><br><br>Scales an image using given scaling factors for X and Y dimensions. The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeBoxSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeBoxSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeBox(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeBox</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeSphereSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeSphereSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeSphere(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeSphere</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip2D(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY)";
       description = "<b>flip2D</b><br><br>Flips an image in X and/or Y direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip3D(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY, Boolean flipZ)";
       description = "<b>flip3D</b><br><br>Flips an image in X, Y and/or Z direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY, Boolean flipZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY)";
       description = "<b>flip</b><br><br>Flips an image in X and/or Y direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateFeatureStack(ClearCLBuffer input, ClearCLBuffer feature_stack_destination, String feature_definitions)";
       description = "<b>generateFeatureStack</b><br><br>Generates a feature stack for Trainable Weka Segmentation. Use this terminology to specifiy which stacks should be generated:<br>* &quot;original&quot; original slice<br>* &quot;GaussianBlur=s&quot; Gaussian blurred image with sigma s<br>* &quot;LaplacianOfGaussian=s&quot; Laplacian of Gaussian blurred image with sigma s<br>* &quot;SobelOfGaussian=s&quot; Sobel filter applied to Gaussian blurred image with sigma s<br>* &quot;minimum=r&quot; local minimum with radius r<br>* &quot;maximum=r&quot; local maximum with radius r<br>* &quot;mean=r&quot; local mean with radius r<br>* &quot;entropy=r&quot; local entropy with radius r<br>* &quot;gradientX&quot; local gradient in X direction<br>* &quot;gradientY&quot; local gradient in Y direction<br><br>Use sigma=0 to apply a filter to the original image. Feature definitions are not case sensitive.<br><br>Example: &quot;original gaussianBlur=1 gaussianBlur=5 laplacianOfGaussian=1 laplacianOfGaussian=7 entropy=3&quot;<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer feature_stack_destination, String feature_definitions";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getSize(ClearCLBuffer source)";
       description = "<b>getSize</b><br><br>Reads out the size of an image [stack] and writes it to the results table in the columns 'Width', 'Height' and 'Depth'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientX(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientX</b><br><br>Computes the gradient of gray values along X. Assuming a, b and c are three adjacent<br> pixels in X direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientY(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientY</b><br><br>Computes the gradient of gray values along Y. Assuming a, b and c are three adjacent<br> pixels in Y direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientZ(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientZ</b><br><br>Computes the gradient of gray values along Z. Assuming a, b and c are three adjacent<br> pixels in Z direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.histogram(ClearCLBuffer source, ClearCLBuffer destination, Integer numberOfBins, Float minimumGreyValue, Float maximumGreyValue, Boolean determineMinAndMax)";
       description = "<b>histogram</b><br><br>Determines the histogram of a given image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer numberOfBins, Float minimumGreyValue, Float maximumGreyValue, Boolean determineMinAndMax";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.invert(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>invert</b><br><br>Computes the negative value of all pixels in a given image. It is recommended to convert images to <br>32-bit float before applying this operation.<br><br><pre>f(x) = - x</pre><br><br>For binary images, use binaryNot.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.jaccardIndex(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>jaccardIndex</b><br><br>Determines the overlap of two binary images using the Jaccard index.<br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The resulting Jaccard index is saved to the results table in the 'Jaccard_Index' column.<br>Note that the Sorensen-Dice coefficient can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localThreshold(ClearCLImageInterface source, ClearCLImageInterface localThreshold, ClearCLImageInterface destination)";
       description = "<b>localThreshold</b><br><br>Computes a binary image with pixel values 0 and 1 depending on if a pixel value x in image X <br>was above of equal to the pixel value m in mask image M.<br><br><pre>f(x) = (1 if (x >=  m)); (0 otherwise)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface localThreshold, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maskStackWithPlane(ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination)";
       description = "<b>maskStackWithPlane</b><br><br>Computes a masked image by applying a 2D mask to an image stack. All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same spatial position in the mask image is not equal to <br>zero.<br><br><pre>f(x,m) = (x if (m != 0); (0 otherwise))</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mask(ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination)";
       description = "<b>mask</b><br><br>Computes a masked image by applying a mask to an image. All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same position in the mask image is not equal to <br>zero.<br><br><pre>f(x,m) = (x if (m != 0); (0 otherwise))</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.matrixEqual(ClearCLBuffer input1, ClearCLBuffer input2, Float tolerance)";
       description = "<b>matrixEqual</b><br><br>Checks if all elements of a matrix are different by less than or equal to a given tolerance.<br>The result will be put in the results table in column &quot;MatrixEqual&quot; as 1 if yes and 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, Float tolerance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximum2DBox</b><br><br>Computes the local maximum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximum2DSphere</b><br><br>Computes the local maximum of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>maximum3DBox</b><br><br>Computes the local maximum of a pixels cube neighborhood. The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>maximum3DSphere</b><br><br>Computes the local maximum of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximumBox</b><br><br>Computes the local maximum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>maximumImageAndScalar</b><br><br>Computes the maximum of a constant scalar s and each pixel value x in a given image X.<br><br><pre>f(x, s) = max(x, s)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumImages(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>maximumImages</b><br><br>Computes the maximum of a pair of pixel values x, y from two given images X and Y.<br><br><pre>f(x, y) = max(x, y)</pre><br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>maximumOfAllPixels</b><br><br>Determines the maximum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Max'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>maximumOfMaskedPixels</b><br><br>Determines the maximum intensity in an image, but only in pixels which have non-zero values in another mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max)";
       description = "<b>maximumZProjection</b><br><br>Determines the maximum projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>mean2DBox</b><br><br>Computes the local mean average of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>mean2DSphere</b><br><br>Computes the local mean average of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>mean3DBox</b><br><br>Computes the local mean average of a pixels cube neighborhood. The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>mean3DSphere</b><br><br>Computes the local mean average of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanClosestSpotDistance(ClearCLBuffer spotsA, ClearCLBuffer spotsB, Boolean bidirectional)";
       description = "<b>meanClosestSpotDistance</b><br><br>Takes two binary images A and B with marked spots and determines for each spot in image A the closest spot in image B. Afterwards, it saves the average shortest distances from image A to image B as 'mean_closest_spot_distance_A_B' and from image B to image A as 'mean_closest_spot_distance_B_A' to the results table. The distance between B and A is only determined if the `bidirectional` checkbox is checked.<br><br>Parameters:<br>ClearCLBuffer spotsA, ClearCLBuffer spotsB, Boolean bidirectional";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfAllPixels(ClearCLImageInterface source)";
       description = "<b>meanOfAllPixels</b><br><br>Determines the mean average of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Mean'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>meanOfMaskedPixels</b><br><br>Determines the mean intensity in an image, but only in pixels which have non-zero values in another binary mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfPixelsAboveThreshold(ClearCLBuffer source, Float threshold)";
       description = "<b>meanOfPixelsAboveThreshold</b><br><br>Determines the mean intensity in an image, but only in pixels which are above a given threshold.<br><br>Parameters:<br>ClearCLBuffer source, Float threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>meanSliceBySliceSphere</b><br><br>Computes the local mean average of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanSquaredError(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>meanSquaredError</b><br><br>Determines the mean squared error (MSE) between two images. The MSE will be stored in a new row of ImageJs<br>Results table in the column 'MSE'.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>meanZProjection</b><br><br>Determines the mean average projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median2DBox</b><br><br>Computes the local median of a pixels rectangular neighborhood. The rectangle is specified by <br>its half-width and half-height (radius).<br><br>For technical reasons, the area of the rectangle must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median2DSphere</b><br><br>Computes the local median of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>For technical reasons, the area of the ellipse must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>median3DBox</b><br><br>Computes the local median of a pixels cuboid neighborhood. The cuboid size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>For technical reasons, the volume of the cuboid must contain less than 1000 voxels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>median3DSphere</b><br><br>Computes the local median of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>For technical reasons, the volume of the sphere must contain less than 1000 voxels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimum2DBox</b><br><br>Computes the local minimum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimum2DSphere</b><br><br>Computes the local minimum of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>minimum3DBox</b><br><br>Computes the local minimum of a pixels cube neighborhood. The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>minimum3DSphere</b><br><br>Computes the local minimum of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimumBox</b><br><br>Computes the local minimum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>minimumImageAndScalar</b><br><br>Computes the maximum of a constant scalar s and each pixel value x in a given image X.<br><br><pre>f(x, s) = min(x, s)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumImages(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>minimumImages</b><br><br>Computes the minimum of a pair of pixel values x, y from two given images X and Y.<br><br><pre>f(x, y) = min(x, y)</pre><br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>minimumOfAllPixels</b><br><br>Determines the minimum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Min'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>minimumOfMaskedPixels</b><br><br>Determines the minimum intensity in an image, but only in pixels which have non-zero values in another mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_sum)";
       description = "<b>minimumZProjection</b><br><br>Determines the minimum projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_sum";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>multiplyImageAndScalar</b><br><br>Multiplies all pixels value x in a given image X with a constant scalar s.<br><br><pre>f(x, s) = x * s</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImages(ClearCLImageInterface factor1, ClearCLImageInterface factor2, ClearCLImageInterface destination)";
       description = "<b>multiplyImages</b><br><br>Multiplies all pairs of pixel values x and y from two image X and Y.<br><br><pre>f(x, y) = x * y</pre><br><br>Parameters:<br>ClearCLImageInterface factor1, ClearCLImageInterface factor2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyStackWithPlane(ClearCLImageInterface sourceStack, ClearCLImageInterface sourcePlane, ClearCLImageInterface destination)";
       description = "<b>multiplyStackWithPlane</b><br><br>Multiplies all pairs of pixel values x and y from an image stack X and a 2D image Y. x and y are at <br>the same spatial position within a plane.<br><br><pre>f(x, y) = x * y</pre><br><br>Parameters:<br>ClearCLImageInterface sourceStack, ClearCLImageInterface sourcePlane, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.organiseWindows(Integer startX, Integer startY, Integer tilesX, Integer tilesY, Integer tileWidth, Integer tileHeight)";
       description = "<b>organiseWindows</b><br><br>Organises windows on screen.<br><br>Parameters:<br>Integer startX, Integer startY, Integer tilesX, Integer tilesY, Integer tileWidth, Integer tileHeight";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.particleImageVelocimetryTimelapse(ClearCLBuffer source, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ, Boolean correctLocalShift)";
       description = "<b>particleImageVelocimetryTimelapse</b><br><br>Run particle image velocimetry on a 2D+t timelapse.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ, Boolean correctLocalShift";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.particleImageVelocimetry(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ, Boolean correctLocalShift)";
       description = "<b>particleImageVelocimetry</b><br><br>For every pixel in source image 1, determine the pixel with the most similar intensity in <br> the local neighborhood with a given radius in source image 2. Write the distance in <br>X and Y in the two corresponding destination images.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ, Boolean correctLocalShift";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.power(ClearCLImageInterface source, ClearCLImageInterface destination, Float exponent)";
       description = "<b>power</b><br><br>Computes all pixels value x to the power of a given exponent a.<br><br><pre>f(x, a) = x ^ a</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float exponent";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.preloadFromDisc(ClearCLBuffer destination, String filename, String nextFilename, String loaderId)";
       description = "<b>preloadFromDisc</b><br><br>This plugin takes two image filenames and loads them into RAM. The first image is returned immediately, the second image is loaded in the background and  will be returned when the plugin is called again.<br><br> It is assumed that all images have the same size. If this is not the case, call release(image) before  getting the second image.<br><br>Parameters:<br>ClearCLBuffer destination, String filename, String nextFilename, String loaderId";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.print(ClearCLImageInterface input)";
       description = "<b>print</b><br><br>Visualises an image on standard out (console).<br><br>Parameters:<br>ClearCLImageInterface input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullAsROI(ClearCLBuffer binary_input)";
       description = "<b>pullAsROI</b><br><br>Pulls a binary image from the GPU memory and puts it on the currently active ImageJ window.<br><br>Parameters:<br>ClearCLBuffer binary_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullLabelsToROIList(ClearCLBuffer labelmap_input)";
       description = "<b>pullLabelsToROIList</b><br><br>Pulls all labels in a label map as ROIs to a list.<br><br>Parameters:<br>ClearCLBuffer labelmap_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullLabelsToROIManager(ClearCLBuffer labelmap_input)";
       description = "<b>pullLabelsToROIManager</b><br><br>Pulls all labels in a label map as ROIs to the ROI manager.<br><br>Parameters:<br>ClearCLBuffer labelmap_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceBottom(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceBottom</b><br><br>Flippes Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method but<br>offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceLeft(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceLeft</b><br><br>Flippes X, Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method <br> but offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceRight(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceRight</b><br><br>Flippes X, Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method <br> but offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceTop(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceTop</b><br><br>Flippes Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method but<br>offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotate2D(ClearCLBuffer source, ClearCLBuffer destination, Float angle, Boolean rotateAroundCenter)";
       description = "<b>rotate2D</b><br><br>Rotates an image in plane. All angles are entered in degrees. If the image is not rotated around <br>the center, it is rotated around the coordinate origin.<br><br>It is recommended to apply the rotation to an isotropic image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float angle, Boolean rotateAroundCenter";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotate3D(ClearCLBuffer source, ClearCLBuffer destination, Float angleX, Float angleY, Float angleZ, Boolean rotateAroundCenter)";
       description = "<b>rotate3D</b><br><br>Rotates an image stack in 3D. All angles are entered in degrees. If the image is not rotated around <br>the center, it is rotated around the coordinate origin.<br><br>It is recommended to apply the rotation to an isotropic image stack.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float angleX, Float angleY, Float angleZ, Boolean rotateAroundCenter";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateLeft(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateLeft</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateRight(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateRight</b><br><br>Rotates a given input image by 90 degrees clockwise. For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.saveAsTIF(ClearCLBuffer input, String filename)";
       description = "<b>saveAsTIF</b><br><br>Pulls an image from the GPU memory and saves it as TIF to disc.<br><br>Parameters:<br>ClearCLBuffer input, String filename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setColumn(ClearCLImageInterface source, Integer columnIndex, Float value)";
       description = "<b>setColumn</b><br><br>Sets all pixel values x of a given column in X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Integer columnIndex, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setImageBorders(ClearCLImageInterface destination, Float value)";
       description = "<b>setImageBorders</b><br><br>Sets all pixel values at the image border to a given value.<br><br>Parameters:<br>ClearCLImageInterface destination, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setNonZeroPixelsToPixelIndex(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>setNonZeroPixelsToPixelIndex</b><br><br>Sets all pixels in an image which are not zero to the index of the pixel. This can be used for Connected Components Analysis.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setPlane(ClearCLImageInterface source, Integer rowIndex, Float value)";
       description = "<b>setPlane</b><br><br>Sets all pixel values x of a given plane in X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Integer rowIndex, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampX(ClearCLImageInterface source)";
       description = "<b>setRampX</b><br><br>Sets all pixel values to their X coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampY(ClearCLImageInterface source)";
       description = "<b>setRampY</b><br><br>Sets all pixel values to their Y coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampZ(ClearCLImageInterface source)";
       description = "<b>setRampZ</b><br><br>Sets all pixel values to their Z coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRandom(ClearCLBuffer source, Float minimumValue, Float maximumValue, Float seed)";
       description = "<b>setRandom</b><br><br>Fills an image or image stack with uniformly distributed random numbers between given minimum and maximum values.<br>Recommendation: For the seed, use getTime().<br><br>Parameters:<br>ClearCLBuffer source, Float minimumValue, Float maximumValue, Float seed";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRow(ClearCLImageInterface source, Integer rowIndex, Float value)";
       description = "<b>setRow</b><br><br>Sets all pixel values x of a given row in X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Integer rowIndex, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXequalsY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXequalsY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x == y. Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br><pre>f(a) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXgreaterThanY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXgreaterThanY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x > y. Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br><pre>f(a) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXsmallerThanY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXsmallerThanY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x < y. Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br><pre>f(a) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.set(ClearCLImageInterface source, Float value)";
       description = "<b>set</b><br><br>Sets all pixel values x of a given image X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showGlasbeyOnGrey(ClearCLBuffer red, ClearCLBuffer labelling, String title)";
       description = "<b>showGlasbeyOnGrey</b><br><br>Visualises two 2D images as one RGB image. The first channel is shown in grey, the second with glasbey LUT.<br><br>Parameters:<br>ClearCLBuffer red, ClearCLBuffer labelling, String title";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showGrey(ClearCLBuffer input, String title)";
       description = "<b>showGrey</b><br><br>Visualises a single 2D image.<br><br>Parameters:<br>ClearCLBuffer input, String title";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showRGB(ClearCLBuffer red, ClearCLBuffer green, ClearCLBuffer blue, String title)";
       description = "<b>showRGB</b><br><br>Visualises three 2D images as one RGB image<br><br>Parameters:<br>ClearCLBuffer red, ClearCLBuffer green, ClearCLBuffer blue, String title";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sorensenDiceCoefficient(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>sorensenDiceCoefficient</b><br><br>Determines the overlap of two binary images using the Sorensen-Dice coefficent.<br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The Sorensen-Dice coefficient is saved in the colum 'Sorensen_Dice_coefficient'.<br>Note that the Sorensen-Dice coefficient s can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationOfAllPixels(ClearCLImageInterface source)";
       description = "<b>standardDeviationOfAllPixels</b><br><br>Determines the standard deviation of all pixels in an image. The value will be stored in a new row of ImageJs<br>Results table in the column 'Standard_deviation'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>standardDeviationOfMaskedPixels</b><br><br>Determines the standard deviation of all pixels in an image which have non-zero value in a corresponding mask image. The value will be stored in a new row of ImageJs<br>Results table in the column 'Masked_standard_deviation'.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.startContinuousWebcamAcquisition(Integer cameraDeviceIndex, Integer imageWidth, Integer imageHeight)";
       description = "<b>startContinuousWebcamAcquisition</b><br><br>Acquires an image (in fact an RGB image stack with three slices) of given size using a webcam. It uses the webcam-capture library by Bartosz Firyn.https://github.com/sarxos/webcam-capture<br><br>Parameters:<br>Integer cameraDeviceIndex, Integer imageWidth, Integer imageHeight";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.statisticsOfLabelledPixels(ClearCLBuffer input, ClearCLBuffer labelmap)";
       description = "<b>statisticsOfLabelledPixels</b><br><br>Determines bounding box, area (in pixels/voxels), min, max and mean intensity  of labelled objects in a label map and corresponding pixels in the original image.Instead of a label map, you can also use a binary image as a binary image is a label map with just one label.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer labelmap";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.stopContinuousWebcamAcquisition(Integer cameraDeviceIndex)";
       description = "<b>stopContinuousWebcamAcquisition</b><br><br>Acquires an image (in fact an RGB image stack with three slices) of given size using a webcam. It uses the webcam-capture library by Bartosz Firyn.https://github.com/sarxos/webcam-capture<br><br>Parameters:<br>Integer cameraDeviceIndex";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.stopWatch(String text)";
       description = "<b>stopWatch</b><br><br>Measures time and outputs delay to last call.<br><br>Parameters:<br>String text";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractImages(ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination)";
       description = "<b>subtractImages</b><br><br>Subtracts one image X from another image Y pixel wise.<br><br><pre>f(x, y) = x - y</pre><br><br>Parameters:<br>ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtract(ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination)";
       description = "<b>subtract</b><br><br>Subtracts one image X from another image Y pixel wise.<br><br><pre>f(x, y) = x - y</pre><br><br>Parameters:<br>ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>sumOfAllPixels</b><br><br>Determines the sum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Sum'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumPixels(ClearCLImageInterface source)";
       description = "<b>sumPixels</b><br><br>Determines the sum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Sum'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_sum)";
       description = "<b>sumZProjection</b><br><br>Determines the sum projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_sum";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.tenengradFusion(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_substacks, Float sigmaX, Float sigmaY, Float sigmaZ, Float exponent)";
       description = "<b>tenengradFusion</b><br><br>Fuses #n# image stacks using Tenengrads algorithm.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_substacks, Float sigmaX, Float sigmaY, Float sigmaZ, Float exponent";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.threshold(ClearCLBuffer source, ClearCLBuffer destination, Float threshold)";
       description = "<b>threshold</b><br><br>Computes a binary image with pixel values 0 and 1. All pixel values x of a given input image with <br>value larger or equal to a given threshold t will be set to 1.<br><br>f(x,t) = (1 if (x >= t); (0 otherwise))<br><br>This plugin is comparable to setting a raw threshold in ImageJ and using the 'Convert to Mask' menu.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.trainWekaModelWithOptions(ClearCLBuffer featureStack3D, ClearCLBuffer groundTruth2D, String saveModelFilename, Integer trees, Integer features, Integer maxDepth)";
       description = "<b>trainWekaModelWithOptions</b><br><br>Trains a Weka model using functionality of Fijis Trainable Weka Segmentation plugin.<br>It takes a 3D feature stack (e.g. first plane original image, second plane blurred, third plane edge image)and trains a Weka model. This model will be saved to disc.<br>The given groundTruth image is supposed to be a label map where pixels with value 1 represent class 1, pixels with value 2 represent class 2 and so on. Pixels with value 0 will be ignored for training.<br><br>Default values for options are:<br>* trees = 200<br>* features = 2<br>* maxDepth = 0<br><br>Parameters:<br>ClearCLBuffer featureStack3D, ClearCLBuffer groundTruth2D, String saveModelFilename, Integer trees, Integer features, Integer maxDepth";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.trainWekaModel(ClearCLBuffer featureStack3D, ClearCLBuffer groundTruth2D, String saveModelFilename)";
       description = "<b>trainWekaModel</b><br><br>Trains a Weka model using functionality of Fijis Trainable Weka Segmentation plugin.<br>It takes a 3D feature stack (e.g. first plane original image, second plane blurred, third plane edge image)and trains a Weka model. This model will be saved to disc.<br>The given groundTruth image is supposed to be a label map where pixels with value 1 represent class 1, pixels with value 2 represent class 2 and so on. Pixels with value 0 will be ignored for training.<br><br>Parameters:<br>ClearCLBuffer featureStack3D, ClearCLBuffer groundTruth2D, String saveModelFilename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translate2D(ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY)";
       description = "<b>translate2D</b><br><br>Translate an image stack in X and Y.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translate3D(ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY, Float translateZ)";
       description = "<b>translate3D</b><br><br>Translate an image stack in X, Y and Z.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY, Float translateZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.varianceOfAllPixels(ClearCLBuffer source)";
       description = "<b>varianceOfAllPixels</b><br><br>Determines the variance of all pixels in an image. The value will be stored in a new row of ImageJs<br>Results table in the column 'Variance'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.varianceOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>varianceOfMaskedPixels</b><br><br>Determines the variance in an image, but only in pixels which have non-zero values in another binary mask image. The result is put in the results table as new column named 'Masked_variance'.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeVTKLineListToDisc(ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, String filename)";
       description = "<b>writeVTKLineListToDisc</b><br><br>Takes a point list image representing n points (n*2 for 2D points, n*3 for 3D points) and a corresponding touch matrix , sized (n+1)*(n+1), and exports them in VTK format.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, String filename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeXYZPointListToDisc(ClearCLBuffer pointlist, String filename)";
       description = "<b>writeXYZPointListToDisc</b><br><br>Takes a point list image representing n points (n*2 for 2D points, n*3 for 3D points) and exports them in XYZ format.<br><br>Parameters:<br>ClearCLBuffer pointlist, String filename";
       list.add(new BasicCompletion(provider, headline, null, description));
        return list;
    }
}
// 158 methods generated.
